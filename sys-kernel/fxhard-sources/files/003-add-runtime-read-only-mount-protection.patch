From b4e457523a2bfc4917da0f5019156013581b5a22 Mon Sep 17 00:00:00 2001
From: madaidan <50278627+madaidan@users.noreply.github.com>
Date: Sun, 12 Apr 2020 23:45:53 +0000
Subject: [PATCH] Add runtime read-only mount protection

This is modified from Brad Spengler/PaX Team's code in the last
public patch of grsecurity/PaX based on my understanding of the code. Changes
or omissions from the original code are mine and don't reflect the original
grsecurity/PaX code.

This creates the fs.romount_protect sysctl to enable read-only mount protection.

If romount_protect is set to (1), filesystems will be
protected in the following ways:
 * No new writable mounts will be allowed
 * Existing read-only mounts won't be able to be remounted read/write
 * Write operations will be denied on all block devices
---
 Documentation/admin-guide/sysctl/fs.rst | 18 +++++++++++++++
 fs/Makefile                             |  2 +-
 fs/namei.c                              |  3 +++
 fs/namespace.c                          |  6 +++++
 fs/rofs.c                               | 29 +++++++++++++++++++++++++
 include/linux/mount.h                   |  4 ++++
 kernel/sysctl.c                         |  9 ++++++++
 7 files changed, 70 insertions(+), 1 deletion(-)
 create mode 100644 fs/rofs.c

diff --git a/Documentation/admin-guide/sysctl/fs.rst b/Documentation/admin-guide/sysctl/fs.rst
index 2a45119e3331..7a49e6062599 100644
--- a/Documentation/admin-guide/sysctl/fs.rst
+++ b/Documentation/admin-guide/sysctl/fs.rst
@@ -45,6 +45,7 @@ Currently, these files are in /proc/sys/fs:
 - protected_hardlinks
 - protected_regular
 - protected_symlinks
+- romount_protect
 - suid_dumpable
 - super-max
 - super-nr
@@ -272,6 +273,23 @@ follower match, or when the directory owner matches the symlink's owner.
 This protection is based on the restrictions in Openwall and grsecurity.
 
 
+romount_protect
+---------------
+
+This toggle enables read-only mount protection.
+
+If romount_protect is set to (0), there are no protections.
+If romount_protect is set to (1), filesystems will be
+protected in the following ways:
+ * No new writable mounts will be allowed
+ * Existing read-only mounts won't be able to be remounted read/write
+ * Write operations will be denied on all block devices
+
+Once romount_protect is set to (1), it cannot be disabled.
+
+This feature is mainly intended for secure embedded systems.
+
+
 suid_dumpable:
 --------------
 
diff --git a/fs/Makefile b/fs/Makefile
index 2ce5112b02c8..7b4cd4d47e2f 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -13,7 +13,7 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		seq_file.o xattr.o libfs.o fs-writeback.o \
 		pnode.o splice.o sync.o utimes.o d_path.o \
 		stack.o fs_struct.o statfs.o fs_pin.o nsfs.o \
-		fs_types.o fs_context.o fs_parser.o fsopen.o
+		fs_types.o fs_context.o fs_parser.o fsopen.o rofs.o
 
 ifeq ($(CONFIG_BLOCK),y)
 obj-y +=	buffer.o block_dev.o direct-io.o mpage.o
diff --git a/fs/namei.c b/fs/namei.c
index e090d33556b3..ea683d3a31e2 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -2867,6 +2867,9 @@ static int may_open(const struct path *path, int acc_mode, int flag)
 	if (flag & O_NOATIME && !inode_owner_or_capable(inode))
 		return -EPERM;
 
+	if (handle_rofs_blockwrite(dentry, path->mnt, acc_mode))
+		return -EPERM;
+
 	return 0;
 }
 
diff --git a/fs/namespace.c b/fs/namespace.c
index a28e4db075ed..de0d6e10c5e3 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -30,6 +30,7 @@
 #include <uapi/linux/mount.h>
 #include <linux/fs_context.h>
 #include <linux/shmem_fs.h>
+#include <linux/mount.h>
 
 #include "pnode.h"
 #include "internal.h"
@@ -3126,6 +3127,11 @@ long do_mount(const char *dev_name, const char __user *dir_name,
 			    SB_LAZYTIME |
 			    SB_I_VERSION);
 
+	if (handle_rofs_mount(path.dentry, path.mnt, mnt_flags)) {
+		retval = -EPERM;
+		goto dput_out;
+	}
+
 	if ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))
 		retval = do_reconfigure_mnt(&path, mnt_flags);
 	else if (flags & MS_REMOUNT)
diff --git a/fs/rofs.c b/fs/rofs.c
new file mode 100644
index 000000000000..54336a998920
--- /dev/null
+++ b/fs/rofs.c
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mount.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+
+int enable_rofs __read_mostly = 0;
+
+int
+handle_rofs_mount(struct dentry *dentry, struct vfsmount *mnt, int mnt_flags)
+{
+	if (enable_rofs && !(mnt_flags & MNT_READONLY))
+		return -EPERM;
+	else
+		return 0;
+}
+
+int
+handle_rofs_blockwrite(struct dentry *dentry, struct vfsmount *mnt, int acc_mode)
+{
+	struct inode *inode = d_backing_inode(dentry);
+
+	if (enable_rofs && (acc_mode & MAY_WRITE) &&
+	    inode && (S_ISBLK(inode->i_mode) || (S_ISCHR(inode->i_mode) && imajor(inode) == RAW_MAJOR)))
+		return -EPERM;
+	else
+		return 0;
+}
diff --git a/include/linux/mount.h b/include/linux/mount.h
index bf8cc4108b8f..2911cb2f0754 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -109,4 +109,8 @@ extern unsigned int sysctl_mount_max;
 
 extern bool path_is_mountpoint(const struct path *path);
 
+extern int enable_rofs;
+extern int handle_rofs_mount(struct dentry *dentry, struct vfsmount *mnt, int mnt_flags);
+extern int handle_rofs_blockwrite(struct dentry *dentry, struct vfsmount *mnt, int acc_mode);
+
 #endif /* _LINUX_MOUNT_H */
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 87bc1d26c376..338a60b37bbc 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1934,6 +1934,15 @@ static struct ctl_table fs_table[] = {
 		.extra1		= SYSCTL_ZERO,
 		.extra2		= &two,
 	},
+	{
+		.procname	= "romount_protect",
+		.data		= &enable_rofs,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax_sysadmin,
+		.extra1		= SYSCTL_ONE,
+		.extra2		= SYSCTL_ONE,
+        },
 	{
 		.procname	= "suid_dumpable",
 		.data		= &suid_dumpable,
